"
============================================
             Code Generation
============================================
"
⟨CG⟩⇐

prologue ← "
// Generated by bqn-lisp codegen
module {
"

epilogue ← "
}
"

# Constants and functions are defined at the module level
consts ← ""
functions ← ""
funcmain ← "
func.func @bl_main() -> i32 {
"
global ← 0

LowerStmt ← {𝕊stmt:
  type ← 1⊑stmt
  
}

MLIRCompile ← {
  cc ← ⟨
    "mlir-opt",
    "--pass-pipeline=func.func(tosa-infer-shapes, tosa-to-linalg-named, tosa-to-linalg, canonicalize, arith-expand, canonicalize)",
    "--func-bufferize",
    "--pass-pipeline=func.func(canonicalize, convert-linalg-to-affine-loops, affine-loop-fusion, lower-affine, finalizing-bufferize, buffer-deallocation, convert-scf-to-cf, convert-math-to-llvm)",
    "--convert-arith-to-llvm",
    "--convert-vector-to-llvm",
    "--convert-cf-to-llvm",
    "--convert-memref-to-llvm",
    "--convert-func-to-llvm",
    "--canonicalize",
    "--reconcile-unrealized-casts",
    "--canonicalize",
    "--llvm-legalize-for-export",
    𝕩
  ⟩
  r‿o‿e ← •Sh cc
  •Out 0⊸=◶{𝕊:"Error occured: "∾e}‿{𝕊:"compilation succeeded"}r
}

CG ← {outfile𝕊tree:
  LowerStmt ¨tree
  funcmain ∾↩ "
  %0 = llvm.mlir.constant(1 : i32) : i32
  return %0 : i32
}
"
  outfile •FChars prologue∾consts∾functions∾funcmain∾epilogue
  mlir ← outfile∾".mlir"
  outfile MLIRCompile mlir
}
