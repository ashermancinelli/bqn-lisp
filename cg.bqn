"
============================================
             Code Generation
============================================
"
âŸ¨CGâŸ©â‡

prologue â† "
// Generated by bqn-lisp codegen
module {
"

epilogue â† "
}
"

# Constants and functions are defined at the module level
consts â† ""
functions â† ""
funcmain â† "
func.func @bl_main() -> i32 {
"
global â† 0

LowerStmt â† {ğ•Šstmt:
  type â† 1âŠ‘stmt
  
}

MLIRCompile â† {
  cc â† âŸ¨
    "mlir-opt",
    "--pass-pipeline=func.func(tosa-infer-shapes, tosa-to-linalg-named, tosa-to-linalg, canonicalize, arith-expand, canonicalize)",
    "--func-bufferize",
    "--pass-pipeline=func.func(canonicalize, convert-linalg-to-affine-loops, affine-loop-fusion, lower-affine, finalizing-bufferize, buffer-deallocation, convert-scf-to-cf, convert-math-to-llvm)",
    "--convert-arith-to-llvm",
    "--convert-vector-to-llvm",
    "--convert-cf-to-llvm",
    "--convert-memref-to-llvm",
    "--convert-func-to-llvm",
    "--canonicalize",
    "--reconcile-unrealized-casts",
    "--canonicalize",
    "--llvm-legalize-for-export",
    ğ•©
  âŸ©
  râ€¿oâ€¿e â† â€¢Sh cc
  â€¢Out 0âŠ¸=â—¶{ğ•Š:"Error occured: "âˆ¾e}â€¿{ğ•Š:"compilation succeeded"}r
}

CG â† {outfileğ•Štree:
  LowerStmt Â¨tree
  funcmain âˆ¾â†© "
  %0 = llvm.mlir.constant(1 : i32) : i32
  return %0 : i32
}
"
  outfile â€¢FChars prologueâˆ¾constsâˆ¾functionsâˆ¾funcmainâˆ¾epilogue
  mlir â† outfileâˆ¾".mlir"
  outfile MLIRCompile mlir
}
