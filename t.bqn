"
============================================
             Tree Generation
============================================
"

âŸ¨t, SplitGroupsâŸ©â†â€¢Import "util.bqn"
âŸ¨treeâŸ©â‡

Parens â† 1âŠ¸âŠ‘â—¶1â€¿Â¯1â€¿0â€¿0

GroupStmts â† {ğ•Štoks:
  mâ†0Â»+`0=+`ParensÂ¨toks
  mâŠ”toks
}

# A statement is a top-level notion which contains some number of
# expressions.
stmts â† âŸ¨âŸ©
exprs â† âŸ¨âŸ©

NestingLvl â† {1Â»+`ParensÂ¨ğ•©}
DropLast â† 1âŠ¸â†“âŒ¾âŒ½

# Pretty nasty way to do this... stringify the tokens and use the l/rparen tokens
# as literal âŸ¨ and âŸ© to make a tree structure, and use â€¢BQN to evaluate it.
NestArgs â† {
  F1â†{(â€¢Fmt ğ•©)âˆ¾","}
  Fâ†{"âŸ¨"âˆ¾(F1Â¨ğ•©)âˆ¾"âŸ©,"}
  argv â† "âŸ¨"âˆ¾(âˆ¾Â´âˆ¾Â´ (1âŠ¸âŠ‘)â—¶"âŸ¨"â€¿"âŸ©,"â€¿Fâ€¿F Â¨ğ•©)âˆ¾"âŸ©"
  â€¢BQN argv
}

iâ†0
AddStmt â† {ğ•Šstmt:
  â€¢Out "adding statement "âˆ¾(â€¢Fmt i+â†©1)
  "empty parens is not a valid expression" ! 2â‰ â‰ stmt
  NumLitâ†(1âŠ¸âŠ‘)â—¶âŸ¨âŠ¢, âŠ¢, âŠ¢, {ğ•Šiâ€¿tâ€¿v:iâ€¿tâ€¿(â€¢BQN v)}âŸ©
  stmt â†© NumLitÂ¨stmt # replace numlits with BQN numbers (instead of strings)
  nest â† NestingLvl stmt
  funcIs â† 0Â»0=1âŠ‘Â¨stmt
  NestArgs stmt
}


Tree â† {ğ•Štoks:
  slist â† GroupStmts toks
  âŠ‘Â¨AddStmtÂ¨slist
}
